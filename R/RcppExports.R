# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#'Fast C++ implementation of agreementvector for 2 matrix pairwise comparisons
#'using sparse matrices
#'
#'To remember PKG_CXXFLAGS = -DARMA_64BIT_WORD
#'
#'@param mat_A a \code{nB x K} matrix of the observations to be matched. Must be integers.
#'@param mat_B a \code{nA x K} matrix of the database into which a match is looked for. Must be integers.
#'@examples
#'mat1 <- matrix(round(rnorm(n=1000, sd=1.2)), ncol=10, nrow=100)
#'mat2 <- rbind(mat1[1:10, ],
#'              matrix(round(rnorm(n=900, sd=1.2)), ncol=10, nrow=90)
#'              )
#'rownames(mat1) <- paste0("A", 1:nrow(mat1))
#'rownames(mat1) <- paste0("B", 1:nrow(mat1))
#'mat1 <- 1*(mat1>1)
#'mat2 <- 1*(mat2>1)
#'
#'@export
agree_C_sparse <- function(mat_A, mat_B) {
    .Call('matchPack_agree_C_sparse', PACKAGE = 'matchPack', mat_A, mat_B)
}

#'Fast C++ implementation of agreementvector for 2 matrix pairwise comparisons
#'
#'To remember PKG_CXXFLAGS = -DARMA_64BIT_WORD
#'
#'@export
agree_C <- function(mat_A, mat_B) {
    .Call('matchPack_agree_C', PACKAGE = 'matchPack', mat_A, mat_B)
}

#'Fast C++ implementation of mean number of 1's in common for a pair of rows, each taken from one 
#'of 2 binary matrices
#'
#'@param mat_A a \code{nB x K} matrix of the observations to be matched. Must be positive integers 
#'(supposed to be binary).
#'@param mat_B a \code{nA x K} matrix of the database into which a match is looked for. Must be 
#'positive integers (supposed to be binary).
#'@examples
#'mat1 <- matrix(round(rnorm(n=500, sd=1.2)), ncol=10, nrow=50)
#'mat2 <- rbind(mat1[1:10, ],
#'              matrix(round(rnorm(n=400, sd=1.2)), ncol=10, nrow=40)
#'              )
#'rownames(mat1) <- paste0("A", 1:nrow(mat1))
#'rownames(mat1) <- paste0("B", 1:nrow(mat1))
#'mat1 <- 1*(mat1>1)
#'mat2 <- 1*(mat2>1)
#'common1Mean_C(mat1, mat2)
#'m <- numeric(50^2)
#'for(i in 1:50){
#' for(j in 1:50){
#'   m[(i-1)*50 + j] <- sum(mat1[i, ]*mat2[j, ])
#' }
#'}
#'mean(m)
#'
#'@export
common1Mean_C <- function(mat_A, mat_B) {
    .Call('matchPack_common1Mean_C', PACKAGE = 'matchPack', mat_A, mat_B)
}

#'C++ implementation of Winkler's Method E step
#'using a sparse agreement  matrix
#'
#'@keywords internal
estep_C_sparse <- function(agreemat, p, m, u, Log = FALSE) {
    .Call('matchPack_estep_C_sparse', PACKAGE = 'matchPack', agreemat, p, m, u, Log)
}

#'Fast C++ implementation of Winkler's Method E step
#'using a sparse agreement  matrix
#'
#'@keywords internal
estep_C_vect_sparse <- function(agreemat, p, m, u, Log = FALSE) {
    .Call('matchPack_estep_C_vect_sparse', PACKAGE = 'matchPack', agreemat, p, m, u, Log)
}

#'Fast C++ implementation of Winkler's Method E step
#'using two sparse matrices 
#'
#'Saving memory while conserving speed by avoiding casting agreemat_neg
#'
#'@keywords internal
estep_C_vect_sparse2 <- function(agreemat, agreemat_neg, p, m, u, Log = FALSE) {
    .Call('matchPack_estep_C_vect_sparse2', PACKAGE = 'matchPack', agreemat, agreemat_neg, p, m, u, Log)
}

#'C++ implementation of Winkler's Method E step
#'
#'@keywords internal
estep_C <- function(agreemat, p, m, u, Log = FALSE) {
    .Call('matchPack_estep_C', PACKAGE = 'matchPack', agreemat, p, m, u, Log)
}

#'Fast C++ implementation of Winkler's Method E step
#'
#'@keywords internal
estep_C_vect <- function(agreemat, p, m, u, Log = FALSE) {
    .Call('matchPack_estep_C_vect', PACKAGE = 'matchPack', agreemat, p, m, u, Log)
}

#'C++ implementation of the E and M steps from Winkler's EM algorithm estimating FS method 
#'using sparse matrices for big sample sizes
#'
#'@keywords internal
EMstep_C_sparse_big <- function(mat_A, mat_B, p, m, u) {
    .Call('matchPack_EMstep_C_sparse_big', PACKAGE = 'matchPack', mat_A, mat_B, p, m, u)
}

#'C++ implementation of the E and M steps from Winkler's EM algorithm estimating FS method 
#'using sparse matrices for big sample sizes
#'
#'@keywords internal
#'@export
Estep_C_sparse_big <- function(mat_A, mat_B, p, m, u, Log = FALSE) {
    .Call('matchPack_Estep_C_sparse_big', PACKAGE = 'matchPack', mat_A, mat_B, p, m, u, Log)
}

#'C++ implementation of the E and M steps from Winkler's EM algorithm estimating FS method 
#'using sparse matrices for big sample sizes
#'
#'@keywords internal
#'@export
Mstep_C_sparse_big <- function(mat_A, mat_B, g_m, g_u, Log = FALSE) {
    .Call('matchPack_Mstep_C_sparse_big', PACKAGE = 'matchPack', mat_A, mat_B, g_m, g_u, Log)
}

#'C++ implementation of the pseudo-likelihood computation 
#'
#'@param Bvec a vector of length K the observations to be matched.
#'@param Amat \code{nA x K} matrix the database into which a match is looked for.
#'@param eps_p a vector of length \code{K} giving the prior discrepancy rate 
#'expected from A to B for the positives, for each variable.
#'@param eps_n a vector of length \code{K} giving the prior discrepancy rate 
#'expected from A to B for the negatives, for each variable.
#'@param piA a vector of length \code{K} giving the prior probabilities of 
#'observing each variable in A.
#'@param piB a vector of length \code{K} giving the prior probabilities of 
#'observing each variable in B.
#'@export
loglikC <- function(Bvec, Amat, eps_p, eps_n, piA, piB) {
    .Call('matchPack_loglikC', PACKAGE = 'matchPack', Bvec, Amat, eps_p, eps_n, piA, piB)
}

#'C++ implementation of the pseudo-likelihood computation 
#'
#'@param Bmat a \code{K x nB} matrix of the observations to be matched.
#'@param Amat a \code{K x nA} matrix of the database into which a match is looked for.
#'@param eps_p a vector of length \code{K} giving the prior discrepancy rate
#'expected from A to B for the positives, for each variable.
#'@param eps_n a vector of length \code{K} giving the prior discrepancy rate
#'expected from A to B for the negatives, for each variable.
#'@param piA a vector of length \code{K} giving the prior probabilities of 
#'observing each variable in A.
#'@param piB a vector of length \code{K} giving the prior probabilities of 
#'observing each variable in B.
#'@export
loglikC_mat <- function(Bmat, Amat, eps_p, eps_n, piA, piB) {
    .Call('matchPack_loglikC_mat', PACKAGE = 'matchPack', Bmat, Amat, eps_p, eps_n, piA, piB)
}

#'Faster C++ implementation of the pseudo-likelihood computation 
#'
#'@param Bmat a \code{K x nB} matrix of the observations to be matched.
#'@param Amat a \code{K x nA} matrix of the database into which a match is looked for.
#'@param eps_p a vector of length \code{K} giving the prior discrepancy rate 
#'expected from A to B for the positives, for each variable.
#'@param eps_n a vector of length \code{K} giving the prior discrepancy rate  
#'expected from A to B for the negatives, for each variable.
#'@param piA a vector of length \code{K} giving the prior probabilities of 
#'observing each variable in A.
#'@param piB a vector of length \code{K} giving the prior probabilities of 
#'observing each variable in B.
#'@export
loglikC_mat_fast <- function(Bmat, Amat, eps_p, eps_n, piA, piB) {
    .Call('matchPack_loglikC_mat_fast', PACKAGE = 'matchPack', Bmat, Amat, eps_p, eps_n, piA, piB)
}

#'Even faster C++ implementation of the pseudo-likelihood computation for binary
#'variables
#'
#'@param Bmat a \code{K x nB} matrix of the observations to be matched.
#'@param Amat a \code{K x nA} matrix of the database into which a match is looked for.
#'@param eps_p a vector of length \code{K} giving the prior discrepancy rate 
#'expected from A to B for the positives, for each variable.
#'@param eps_n a vector of length \code{K} giving the prior discrepancy rate
#'expected from A to B for the negatives, for each variable.
#'@param piA a vector of length \code{K} giving the prior probabilities of 
#'observing each variable in A.
#'@param piB a vector of length \code{K} giving the prior probabilities of 
#'observing each variable in B.
#'@export
loglikC_bin <- function(Bmat, Amat, eps_p, eps_n, piA, piB) {
    .Call('matchPack_loglikC_bin', PACKAGE = 'matchPack', Bmat, Amat, eps_p, eps_n, piA, piB)
}

#' Splitting a character string in C++
#' 
#' @examples
#' strsplitC(c(";aaa;bb;cccc;ee;"), sep=";")
#'@export
strsplitC <- function(s, sep) {
    .Call('matchPack_strsplitC', PACKAGE = 'matchPack', s, sep)
}

#'C++ implementation of the pseudo-likelihood computation for binary
#'variables with dates
#'
#'@param Bmat a \code{nB x K} matrix of the observations to be matched.
#'@param Amat a \code{nA x K} matrix of the database into which a match is looked for.
#'@param Bdates a \code{nB x K} matrix of the dates for each observations to be matched.
#'@param Adates a \code{nA x K} matrix of the dates for database into which a match is looked for.
#'@param eps_p a vector of length \code{K} giving the prior discrepancy rate 
#'expected from A to B for the positives, for each variable.
#'@param eps_n a vector of length \code{K} giving the prior discrepancy rate
#'expected from A to B for the negatives, for each variable.
#'@param piA a vector of length \code{K} giving the prior probabilities of 
#'observing each variable in A.
#'@param piB a vector of length \code{K} giving the prior probabilities of 
#'observing each variable in B.
#'@export
loglikC_bin_wDates <- function(Bmat, Amat, Bdates, Adates, eps_p, eps_n, piA, piB) {
    .Call('matchPack_loglikC_bin_wDates', PACKAGE = 'matchPack', Bmat, Amat, Bdates, Adates, eps_p, eps_n, piA, piB)
}

#'Fast C++ implementation of the log-likelihood ratio computation for 
#'differentiating variables
#'
#'@param Bmat a \code{K x nB} matrix of the observations to be matched.
#'@param Amat a \code{K x nA} matrix of the database into which a match is looked for.
#'@param eps_same a vector of length \code{K} giving the prior probability rate 
#'expected from A to B for the positives, for each variable.
#'@param eps_n a vector of length \code{K} giving the prior discrepancy rate
#'expected from A to B for the negatives, for each variable.
#'@param piA a vector of length \code{K} giving the prior probabilities of 
#'observing each variable in A.
#'@param piB a vector of length \code{K} giving the prior probabilities of 
#'observing each variable in B.
#'@export
loglikratioC_diff <- function(Bmat, Amat, d_max, eps_inf, pi_inf) {
    .Call('matchPack_loglikratioC_diff', PACKAGE = 'matchPack', Bmat, Amat, d_max, eps_inf, pi_inf)
}

#'Fast C++ implementation of the log-likelihood ratio computation for 
#'differentiating variables
#'
#'@param Bmat a \code{K x nB} matrix of the observations to be matched.
#'@param Amat a \code{K x nA} matrix of the database into which a match is looked for.
#'@param dmax a numeric vector of length \code{K} giving the minimum difference 
#'from which it is considered a discrepency.
#'@param cost a numeric vector of length \code{K} giving the arbitrary cost of discrepency.
#'@export
loglikratioC_diff_arbitrary <- function(Bmat, Amat, d_max, cost) {
    .Call('matchPack_loglikratioC_diff_arbitrary', PACKAGE = 'matchPack', Bmat, Amat, d_max, cost)
}

#'Fast C++ implementation of agreementvector for 2 matrix pairwise comparisons
#'using sparse matrices
#'
#'@param mat_A a \code{nB x K} matrix of the observations to be matched.
#'@param mat_B a \code{nA x K} matrix of the database into which a match is looked for.
#'@export
matchingScore_C_sparse <- function(agreemat, m, u, nA, nB) {
    .Call('matchPack_matchingScore_C_sparse', PACKAGE = 'matchPack', agreemat, m, u, nA, nB)
}

#'Fast C++ implementation of agreementvector for 2 matrix pairwise comparisons
#'
#'@param mat_A a \code{nB x K} matrix of the observations to be matched.
#'@param mat_B a \code{nA x K} matrix of the database into which a match is looked for.
#'
#'@export
matchingScore_C <- function(agreemat, m, u, nA, nB) {
    .Call('matchPack_matchingScore_C', PACKAGE = 'matchPack', agreemat, m, u, nA, nB)
}

#'C++ implementation of agreementvector for 2 matrix pairwise comparisons
#'using sparse matrices
#'
#'@param mat_A a \code{nB x K} matrix of the observations to be matched.
#'@param mat_B a \code{nA x K} matrix of the database into which a match is looked for.
#'@export
matchingScore_C_sparse_big <- function(mat_A, mat_B, m, u) {
    .Call('matchPack_matchingScore_C_sparse_big', PACKAGE = 'matchPack', mat_A, mat_B, m, u)
}

#'Compute the probabilities for an observation to match other observations
#'
#'C++ version: for a given observation of index id0 (in \code{1:n}), all the matching probabilities are computed
#'for the other \code{p} observations.
#'
#'@param id0 the index for the reference observation in \code{1:n} to be match to p other observations
#'@param computed_dist an \code{n x p} matrix of computed distances used for ranking.
#'@param prop_match estimated proportion of match ("rho_1")
#'@param yes_aggregate logical flag for wether the results are sorted according to the
#'original probability or the aggregated probability. Default is \code{TRUE}.
#'@param k0 number of top (highest) matching probabilities to return. 
#'Default is 5.
#'
#'@return a character vector of length \code{k0*4} containing for each k0
#'potential match, inturn, the probability, the aggregated probability, the logLR 
#'abd the corresponding potential matching ID.
#'
#'@export
matchProbs_rank_full_C <- function(computed_dist, prop_match) {
    .Call('matchPack_matchProbs_rank_full_C', PACKAGE = 'matchPack', computed_dist, prop_match)
}

#' Splitting a character string in C++
#' 
#' @examples
#' strsplitC2(c(";aaa;bb ; cccc;ee;"), sep=";")
#'@export
strsplitC_memoryPbs <- function(s, sep) {
    .Call('matchPack_strsplitC_memoryPbs', PACKAGE = 'matchPack', s, sep)
}

#' Splitting a character string in C++
#' 
#' @examples
#' strsplitC_safe(c(";aaa;bb ; cccc;ee;"), sep=";")
#' strsplitC_safe(c(""), sep=";")
#' strsplitC_safe(c("a"), sep=";")
#' strsplitC_safe(c("bb ; ee"), sep=";")
#'@export
strsplitC_safe <- function(s, sep) {
    .Call('matchPack_strsplitC_safe', PACKAGE = 'matchPack', s, sep)
}

#' Splitting a character string in C++
#' 
#' @examples
#' stringdate_test(matrix(c("20NOV2008:21NOV2008", "20NOV2008:21NOV2008 ; 10APR2008:12APR2008", "", ""), ncol=2, nrow=2), 1,0)
#'@export
stringdate_test <- function(Adates, i, l) {
    .Call('matchPack_stringdate_test', PACKAGE = 'matchPack', Adates, i, l)
}

#' Test function in C++
#' 
#' @examples
#'datetest("20NOV2008 ", "%b%d%Y")
#'datetest(" Feb 10 2008 12:00AM", " %b  %d %Y")
#'datetest(" Feb 10 2008 12:00AM", " %b  %d %Y")>=datetest(" Feb 26 2008 12:00AM", " %b  %d %Y")
#'datetest(" Nov  3 2008 12:00AM", "04NOV2008", " %b %d %Y", "%d%b%Y")
#'@export
datetest <- function(s1, s2, fmt1, fmt2) {
    .Call('matchPack_datetest', PACKAGE = 'matchPack', s1, s2, fmt1, fmt2)
}

#' Test function in C++
#' 
#' @examples
#'dateread(" Feb  10 2008 12:00AM", "%b%d%Y")
#'dateread(" Feb  10 2008 12:00AM", " %b  %d %Y")
#'@export
dateread <- function(s, fmt) {
    .Call('matchPack_dateread', PACKAGE = 'matchPack', s, fmt)
}

